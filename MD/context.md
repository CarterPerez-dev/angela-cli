# I couldnt give you all teh files i have currently in repository so i haev thsi file to provide you some conetxxt regaridng teh files you may not be able to directly see. Aswell as a directopry tree/structure/hiererechy


## heres a breif description of each .py file you cannot directly see / see the code in them

Okay, I will describe each file you provide in exactly 5 sentences, focusing on maximum context, technical details, purpose, and code aspects.

---
**File: `angela/workflows/sharing.py`**

`angela/workflows/sharing.py` facilitates sharing workflows by enabling their export into packaged `.angela-workflow` zip files and subsequent import into the Angela system. It defines a `WorkflowExportMetadata` Pydantic model to structure package information, including ID, name, version, author, timestamps, and a SHA-256 checksum generated by `hashlib` for data integrity. The `WorkflowSharingManager` class orchestrates the export process by packaging `workflow.json` (workflow data), `metadata.json`, and a `README.md` into a zip archive, and the import process by extracting, validating the checksum, and adding the workflow via `WorkflowManager`. Export functionality can optionally detect external dependencies like Python or Node.js versions by asynchronously running shell commands (e.g., `python --version`) and includes this in the metadata. The module robustly utilizes `tempfile` for temporary directories, `datetime` for timestamps, `uuid` for unique package IDs, and `pathlib` for filesystem path manipulations.

---
**File: `angela/workflows/manager.py` (inferred from context)**

The file `angela/workflows/manager.py` provides the core `WorkflowManager` class for defining, storing, retrieving, and executing reusable command sequences, known as workflows, within the Angela CLI. It utilizes Pydantic models, `WorkflowStep` (detailing command, explanation, optionality, confirmation needs) and `Workflow` (encompassing name, description, steps, variables, timestamps, tags, author), to structure workflow data. Workflows are persisted in a `workflows.json` file within the application's configuration directory (`CONFIG_DIR`), with the manager handling loading at startup and saving upon modification, including `datetime` to ISO format serialization. A key feature is the `define_workflow_from_natural_language` async method, which leverages an AI (Gemini client) and a `TaskPlanner` to convert user descriptions into structured workflow steps and identify potential variables. Workflow execution involves substituting provided variable values into command templates, converting the workflow into a `TaskPlan`, and then running this plan via the `task_planner`, supporting both regular execution and dry runs.

---
**File: `angela/ai/content_analyzer_extensions.py`**

The `angela/ai/content_analyzer_extensions.py` file introduces `EnhancedContentAnalyzer`, a class that extends the base `ContentAnalyzer` to provide specialized analysis for a wider range of file types and programming languages. It employs a `LANGUAGE_HANDLERS` dictionary to route file analysis requests to language-specific async methods, such as `_analyze_typescript` or `_analyze_json`, based on detected file information from `_get_file_info`. For instance, `_analyze_typescript` uses custom AI prompts for TypeScript code analysis via `_get_ai_analysis` (calling Gemini) and regex patterns (in `_extract_typescript_types`) to identify types and interfaces. Similarly, `_analyze_json` validates JSON content using `json.loads`, infers a basic schema through `_infer_json_schema` by recursively examining data types, and leverages AI for a human-readable structural analysis. If no specific handler is found for a language, the `EnhancedContentAnalyzer` falls back to the `analyze_content` method of its parent class, ensuring general analysis capabilities remain.

---
**File: `angela/ai/parser.py`**

The `angela/ai/parser.py` file is responsible for parsing responses from an AI model, aiming to convert potentially unstructured text into a structured `CommandSuggestion` object. It defines the `CommandSuggestion` Pydantic model, which specifies the expected fields: `intent`, `command`, `explanation`, and optional `additional_info`, ensuring data integrity and providing typed access. The core `parse_ai_response` function intelligently attempts to locate and extract JSON data from the AI's output, specifically looking for JSON within markdown code blocks (e.g., ```json ... ```) or assuming the entire response is JSON. After extracting the JSON string, it uses `json.loads` for parsing and then Pydantic for validation against the `CommandSuggestion` model, logging success or errors. In cases of `json.JSONDecodeError` or Pydantic `ValidationError`, a fallback mechanism employs regular expressions (`re.search`) to try and salvage at least the `command` string, enhancing the parser's resilience to malformed AI responses.

---
**File: `angela/ai/confidence.py`**

`angela/ai/confidence.py` introduces the `ConfidenceScorer` class, designed to evaluate and assign a numerical confidence score (ranging from 0.0 to 1.0) to AI-generated command suggestions. The primary method, `score_command_confidence`, aggregates scores from multiple weighted heuristics: `_check_history` (queries `history_manager` for command frequency and success rate), `_check_complexity` (compares token counts of request and command), `_check_entities` (basic check for entity type matches like files/dirs), and `_check_command_flags` (looks for unusual/conflicting flags). Each heuristic function, like `_check_complexity` which compares request and command token lengths, contributes a value that is then weighted into the final score. The entity check (`_check_entities`) uses simple string matching for terms like "file" or "directory" and `re.findall` for path patterns. The module ensures the final confidence score remains within the 0.0 to 1.0 range and logs the breakdown of contributing factors for debuggability.

---
**File: `angela/integrations.py`**

The `angela/integrations.py` file defines the `PhaseIntegration` class, serving as a central module for initializing and managing a suite of advanced "Phase 5.5" features for autonomous task orchestration and proactive assistance. Its `initialize` async method selectively activates components based on configuration, such as project inference by calling `project_inference.infer_project_info` from `angela.context.project_inference`, and network monitoring by starting `network_monitor`. The `get_enhanced_context` method aggregates information from these active features, like inferred project details or network status, to provide richer contextual data for AI interactions. It integrates error handling via an `ErrorRecoveryManager` through the `handle_execution_error` method and enhances content analysis by routing requests to the `EnhancedContentAnalyzer` (from `angela.ai.content_analyzer_extensions`) with added project context. A `status` async method offers a snapshot of the active integrations, including project type inferred by `project_inference` and basic network monitoring status, showcasing the system's current capabilities.

---
**File: `angela/config.py` (inferred from content)**

This configuration management file, `angela/config.py`, establishes a `ConfigManager` class to handle application settings using TOML for file-based configuration and environment variables for sensitive data like API keys. It employs Pydantic models (`ApiConfig`, `UserConfig`, `AppConfig`) to define a clear structure for settings such as Gemini API keys, default project root (`Path`), `confirm_all_actions` (bool), and `debug` mode, ensuring type validation. The manager dynamically selects TOML parsing libraries (`tomllib` for Python 3.11+ or `tomli` for older versions, and `tomli-w` for writing), loading from a predefined `CONFIG_FILE` path and `.env` files via `python-dotenv`. `load_config` reads the TOML file, populates the Pydantic models, and gracefully handles potential `TOMLDecodeError` or missing files by falling back to defaults or saving a new default configuration. The `save_config` method serializes the current `AppConfig` model (converting `Path` objects to strings for TOML compatibility) back to the configuration file, while a global `config_manager` instance ensures the loaded configuration is immediately available upon module import.

---
**File: `angela/cli/files.py` (inferred from content)**

This file, `angela/cli/files.py`, defines a Typer-based command-line interface application for managing file and directory operations within the Angela CLI, offering an enhanced user experience through the `rich` library. It implements common filesystem commands such as `ls` (with detailed table views via `rich.Table` and color-coding), `mkdir`, `rmdir`, `touch`, `cat` (with syntax highlighting using `rich.Syntax` based on `context_manager.get_file_info`), `rm`, `cp`, `mv`, and `write` (with interactive content input via `rich.Prompt`). These commands primarily delegate their core logic to async functions from `angela.execution.filesystem` (e.g., `create_directory`, `read_file`) and use `angela.context.context_manager` for path resolution and file metadata. Advanced commands include `find` for pattern-based file searching via `context_manager.find_files` and `info` for displaying detailed file/directory information using `rich.Panel` and content previews. A crucial feature is the `rollback` command, which interacts with `angela.execution.rollback.rollback_manager` to list recent operations and allow users to undo them if backups are available, confirming actions with `rich.Confirm`.

---
**File: `angela/cli/workflows.py` (inferred from content)**

This file, `angela/cli/workflows.py`, implements a Typer-based command-line interface for managing Angela workflows, allowing users to list, create, run, delete, show, export, and import these reusable command sequences. It relies on `angela.workflows.manager.workflow_manager` for core operations like defining workflows (interactively via `rich.Prompt` or from natural language in a file via `create`), executing them with variable substitution (`run`), and managing their lifecycle (`list`, `delete`, `show`). The `export` and `import` commands interface with `angela.workflows.sharing.workflow_sharing_manager` to package workflows into shareable `.angela-workflow` archives and to integrate received packages into the system, handling potential renames or replacements. User interaction is enhanced using the `rich` library, providing formatted tables for listing workflows (`rich.Table`), detailed panels for showing workflow steps via `terminal_formatter.display_workflow`, and interactive prompts/confirmations (`rich.Prompt`, `rich.Confirm`). The `run` command supports dry-run mode for previewing execution and accepts variables via command-line options (`--var NAME=VALUE`), which are then passed to the `workflow_manager` for execution within the current `context_manager` context.

---
**File: `angela/context/history.py`**

`angela/context/history.py` implements the `HistoryManager` class to record and analyze user command execution history, persisting data in `command_history.json` (for `CommandRecord`s) and `command_patterns.json` (for `CommandPattern`s) within the `CONFIG_DIR`. It uses a `CommandRecord` class to store detailed information about each command execution, including the command string, natural language request, success status, ISO-formatted timestamp, output, error, and risk level. The `CommandPattern` class tracks metrics like execution count, success rate, and last used timestamp for base commands (e.g., "git commit", extracted by `_extract_base_command`), which are updated via `_update_patterns` if `auto_learn_patterns` preference is enabled. `HistoryManager` loads history and patterns upon initialization, trims history based on `preferences_manager.preferences.context.max_history_items`, and provides methods to retrieve recent commands, query command frequency/success rates, and search for similar past commands using Jaccard similarity on tokenized natural requests. This historical data is crucial for features like adaptive confirmation scoring, command suggestions, and potentially for AI fine-tuning or error recovery within the Angela CLI.

---
**File: `angela/execution/rollback.py` (inferred from content)**

This file, `angela/execution/rollback.py`, implements a `RollbackManager` to provide undo functionality for file and directory operations performed by the Angela CLI, storing its state in `operation_history.json`. It defines an `OperationRecord` class to store details of each recorded action, including its type (e.g., "create_file", "delete_directory"), parameters, ISO-formatted timestamp, and the path to any created backup within the `BACKUP_DIR`. The manager loads this history on initialization and saves updates when `record_operation` is called after a filesystem action. The `rollback_operation` async method is central to the undo logic: based on the `operation_type` and `backup_path` from the selected `OperationRecord`, it reverses the original action, such as deleting a created file or restoring a deleted file/directory from its backup using `shutil` functions like `copy2` or `copytree`. Users can view recent undoable operations (formatted by `_get_operation_description`) via `get_recent_operations`, and upon successful rollback, the manager truncates the history to reflect the undone state.

---
**File: `angela/monitoring/network_monitor.py`**

`angela/monitoring/network_monitor.py` defines the `NetworkMonitor` class, responsible for proactively overseeing various network-related aspects such as local service availability, project dependency updates, and general internet connectivity. It utilizes `asyncio` to run concurrent monitoring tasks: `_monitor_local_services` periodically checks common service ports (e.g., 8000, 5432 using `socket.connect_ex` and `aiohttp` for HTTP checks), tailored by project type from `context_manager`. The `_monitor_dependency_updates` task checks for new versions of Python packages (via `pip list --outdated --format=json`) and Node.js packages (via `npm outdated --json`) relevant to the current project by running these as shell commands using the `_run_command` async helper. General network health is assessed by `_monitor_network_connectivity`, which attempts to resolve well-known domains using `asyncio.get_event_loop().getaddrinfo`. When issues or updates are detected, and a suggestion cooldown period managed by `_can_show_suggestion` and `_last_suggestion_time` has passed, the monitor uses `terminal_formatter.print_proactive_suggestion` to inform the user, enhancing Angela's proactive assistance capabilities.

---
**File: `angela/safety/__init__.py`**

The `angela/safety/__init__.py` file serves as the primary public interface and orchestrator for Angela's comprehensive safety system, consolidating functionalities from its various sub-modules. It imports key components such as `classify_command_risk` and `analyze_command_impact` from `.classifier`, `validate_command_safety` and `validate_operation` from `.validator`, `get_confirmation` from `.confirmation` (likely adaptive confirmation), and `generate_preview` from `.preview`. The central async function `check_command_safety` orchestrates a multi-step safety protocol for shell commands: it first validates the command, then classifies its risk and analyzes impact, generates a preview if possible, and finally obtains user confirmation. Similarly, the `check_operation_safety` async function handles safety checks for higher-level abstract operations (e.g., 'create_file') by validating parameters and, where possible, converting them to equivalent shell commands for the full risk analysis pipeline or applying simplified risk logic. This unified approach ensures that both direct shell commands and abstracted operations undergo consistent and thorough safety scrutiny before any execution is attempted by the Angela CLI.

---
**File: `angela/safety/adaptive_confirmation.py`**

`angela/safety/adaptive_confirmation.py` implements an intelligent user confirmation system that adapts its prompting behavior based on command risk, execution history, and user preferences. It leverages `prompt_toolkit`'s `yes_no_dialog` for interactive user consent and `rich` library components (`Console`, `Panel`, `Syntax`, `Table`) for presenting detailed, styled information, including command syntax, risk levels (using `CONFIRMATION_STYLES`), impact analysis, and previews. The core async function `get_adaptive_confirmation` determines whether to auto-execute a command by consulting `preferences_manager` (for trusted commands) and `history_manager` (for frequency/success rate), or to proceed with explicit user prompting. It tailors the confirmation UI: `_get_detailed_confirmation` is used for high/critical risk operations showing comprehensive details and impact tables, while `_get_simple_confirmation` provides a more concise prompt for lower risks; dry runs (`_show_dry_run_preview`) bypass confirmation entirely. After a successful execution of certain commands, `offer_command_learning` may prompt the user to add the command to their trusted list, further personalizing the safety behavior.

---
**File: `angela/safety/classifier.py`**

`angela/safety/classifier.py` is responsible for assessing the potential danger of shell commands by classifying their risk level and analyzing their likely impact on the system. The `classify_command_risk` function determines a command's risk by matching it against a predefined dictionary of regular expressions, `RISK_PATTERNS` (mapping risk levels to regexes and reasons, e.g., `rm -rf` as CRITICAL) and `OVERRIDE_PATTERNS` (for special cases), categorizing it from "SAFE" to "CRITICAL" as defined in `angela.constants.RISK_LEVELS`. These patterns are designed to identify operations like file deletion, package management, privileged execution (`sudo`), or disk formatting, assigning appropriate risk scores. The `analyze_command_impact` function performs a lexical analysis of the command using `shlex.split` to tokenize it, then heuristically identifies potential operations (e.g., delete, create, read), affected files/directories, and flags if the command is destructive or modifies/creates files. This classification and impact analysis data is then consumed by other safety modules to determine the appropriate level of user confirmation and the details to display.

---
**File: `angela/safety/confirmation.py`**

`angela/safety/confirmation.py` manages the user interaction phase of the safety workflow, presenting detailed information about a command and prompting for explicit user approval before execution. The `requires_confirmation` function determines if a prompt is necessary by checking the command's risk level against `DEFAULT_CONFIRMATION_REQUIREMENTS` and global user settings like `config_manager.config.user.confirm_all_actions`. The `get_confirmation` async function orchestrates the display using the `rich` library, showing the command with `Syntax` highlighting, its `risk_level` (colored using `RISK_COLORS` and named via `RISK_LEVEL_NAMES`), the `risk_reason`, an impact analysis table generated by `format_impact_analysis`, and any available `preview`. It utilizes `rich.Panel` for structuring information clearly and `rich.Confirm.ask` to get a boolean (yes/no) response from the user regarding whether to proceed with the command. For "CRITICAL" risk operations or if `dry_run` is true, additional specific warnings or informational messages are displayed to ensure the user is fully aware of the context and potential consequences.

---
**File: `angela/safety/preview.py`**

`angela/safety/preview.py` is dedicated to generating predictive textual summaries of what shell commands are expected to do, without actually executing them, to aid user decision-making during safety checks. It features a main `generate_preview` async function that dispatches to command-specific async handlers (e.g., `preview_mkdir`, `preview_rm`, `preview_ls`) listed in the `PREVIEWABLE_COMMANDS` dictionary, based on the parsed command (tokenized using `shlex.split`). These specific preview functions, like `preview_rm` or `preview_cp`, analyze command arguments, check file/directory existence and types using `pathlib.Path`, expand glob patterns using `glob.glob`, and then construct a human-readable summary of intended actions, including warnings for overwrites or non-existent paths. For example, `preview_cat` estimates file size and line count for text files or warns about displaying binary content, while `preview_find` describes the search scope and criteria. If no specialized previewer exists for a command, `generic_preview` attempts to execute it with common dry-run flags (e.g., `--dry-run`, `--print`) using `execution_engine.execute_command`, capturing its output as the preview.

---
**File: `angela/safety/validator.py`**

`angela/safety/validator.py` enforces safety policies by validating commands and operations against a set of predefined rules and system constraints before they can proceed to execution. The `validate_command_safety` function scrutinizes raw shell commands, checking them against `DANGEROUS_PATTERNS` (a list of regexes for forbidden actions like `rm -rf /` or `mkfs /dev/sda`) and ensuring necessary superuser privileges (checked via `is_superuser` which uses `os.geteuid`, and `ROOT_PATTERNS` regex list) are met if the current user is not root. The `validate_operation` function handles abstracted operations (e.g., 'create_file', 'delete_directory'), leveraging `check_file_permission` (which employs `os.access`) to verify read/write permissions for specified `Path` objects and checking against deletion of system directories. It defines a custom `ValidationError` exception, although it is not explicitly raised in the provided snippet, it's implied for severe validation failures not handled by returning a boolean and message. This module acts as a critical first line of defense, aiming to prevent overtly harmful or permission-violating operations from even being considered for execution by the Angela CLI.

---
**File: `angela/execution/error_recovery.py`:**
The `angela/execution/error_recovery.py` file implements the `ErrorRecoveryManager` class, a sophisticated system designed to intelligently handle and attempt recovery from errors encountered during multi-step command executions within the Angela CLI. Its primary entry point, the async `handle_error` method, orchestrates a sequence involving error information extraction (command, stderr), detailed analysis via `_analyze_error` which uses an external `error_analyzer` and internal regex patterns from `_get_common_error_patterns`, and generation of potential `RecoveryStrategy` enums (like `RETRY`, `MODIFY_COMMAND`, `PREPARE_ENV`) through `_generate_recovery_strategies`. Strategy generation is multi-faceted: `_generate_recovery_strategies` first attempts to derive actions by parsing fix suggestions from the error analysis using regex in `_parse_fix_suggestion` and `_create_strategy_from_pattern_fix`, and if these heuristic methods yield insufficient results, it queries the `gemini_client` via `_generate_ai_recovery_strategies` with a structured JSON-expecting prompt for AI-driven solutions. These strategies, which are standard Python dictionaries adhering to a defined structure including type, command, description, and confidence, are then sorted by their confidence score, always including fallback options like simple retry or skipping the problematic step.
Automatic recovery, determined by `_can_auto_recover`, is attempted for high-confidence strategies or those with a proven success record tracked in the internal `_recovery_history` dictionary (which logs successful strategy applications like `{ "type:command": {"success_count": N}}`). The `_execute_recovery_strategy` async method performs the actual recovery by dispatching actions based on the strategy type, often involving command execution via the `angela.execution.engine.execution_engine`, where safety checks might be selectively skipped for retries or enforced for newly generated commands. Notably, strategies such as `PREPARE_ENV` can execute a preparatory command (e.g., `mkdir` for a missing directory, or `apt-get install` for a missing package) and, if successful and indicated by a `retry_original` flag within the strategy dictionary, will subsequently re-attempt the original failed command. If automatic recovery isn't viable or fails, `_guided_recovery` presents the generated strategies to the user via `terminal_formatter` for display and uses `prompt_toolkit.input_dialog` to capture their choice, subsequently executing the selected strategy. The system thus combines heuristic rule-based error matching, AI-powered suggestion generation, a learning mechanism from past successful recoveries, and user-guided intervention to maximize the chances of successful task completion.
----------

**Summary for `BackgroundMonitor`:**

This Python module implements an asynchronous `BackgroundMonitor` class for the Angela CLI, designed to proactively assist users by observing system state and activities through concurrent, restartable `asyncio` tasks. It actively monitors Git repository status by periodically running `git status -s`, analyzing changes like modified, untracked, or deleted files, and then generating contextual suggestions for commits or additions if significant activity is detected, subject to a cooldown period and repetition avoidance. The monitor also tracks file modifications within the project, identified by `_find_source_files`, and upon detecting changes, it invokes language-specific checkers such as `python -m py_compile` and `flake8` for Python or `node --check` and `eslint` for JavaScript to report syntax errors and linting issues. System resource monitoring is partially implemented, focusing on disk usage by executing platform-specific commands (`wmic` or `df`) via an asynchronous `_run_command` utility, and it alerts the user if usage exceeds a threshold and has significantly increased. All suggestions are managed to prevent repetition using a set of seen suggestions and are displayed via `terminal_formatter`, with overall monitoring controlled by `start_monitoring` and `stop_monitoring` methods that manage the lifecycle of the underlying `asyncio` tasks.

**Summary for `ProjectInference`**

The `ProjectInference` Python module provides advanced, asynchronous capabilities to analyze a given project directory, aiming to deduce its primary type, technological stack, dependencies, and structural characteristics using file system inspection and pattern matching. It determines the project type (e.g., Python, Node, Java) by scoring matches against predefined `PROJECT_SIGNATURES` that include characteristic files (like `requirements.txt` or `package.json`), directories (e.g., `venv`, `node_modules`), and common file extensions, capable of identifying mixed-type projects by combining high-scoring candidates. Framework detection is achieved by cross-referencing project files and contents against `FRAMEWORK_SIGNATURES` (e.g., identifying Django via `manage.py` or React via `package.json` dependencies) and by directly parsing dependency lists from files like `requirements.txt` or `package.json` using dedicated analyzer methods. The module meticulously extracts project dependencies by parsing specific manifest files corresponding to the detected project type, such as `requirements.txt`, `setup.py`, and `pyproject.toml` for Python projects, or `package.json` for Node.js projects, detailing dependency names, version specifiers, and source files. It identifies and lists important project files, including signature files that confirmed the project type, common documentation like READMEs and LICENSEs, and attempts to locate potential entry point files (e.g., `main.py`, `index.js`) based on conventional naming within the project structure. Project structure analysis involves counting files by extension, identifying prominent subdirectories (ignoring common ones like `.git` or `node_modules`), and generating a hierarchical, depth-limited tree representation of the directory layout using the recursive `_generate_directory_structure` method. All inferred information, including project root, type, detected files, frameworks, dependencies, and structural details, is compiled into a comprehensive dictionary, with results cached per project root path to optimize subsequent analyses of the same project.










# Current Project Tree/Structure
```bash
.
├── MD
│   ├── Info.md
│   ├── Phase1.md
│   ├── Phase2.md
│   ├── Phase3.md
│   ├── Phase4.md
│   ├── Phase5.md
│   └── context.md
├── Makefile
├── README.md
├── angela
│   ├── __init__.py
│   ├── __main__.py
│   ├── ai
│   │   ├── analyzer.py
│   │   ├── client.py
│   │   ├── confidence.py
│   │   ├── content_analyzer.py
│   │   ├── content_analyzer_extensions.py
│   │   ├── file_integration.py
│   │   ├── intent_analyzer.py
│   │   ├── parser.py
│   │   └── prompts.py
│   ├── cli
│   │   ├── __init__.py
│   │   ├── files.py
│   │   ├── main.py
│   │   └── workflows.py
│   ├── cli.py
│   ├── config.py
│   ├── constants.py
│   ├── context
│   │   ├── __init__.py
│   │   ├── file_detector.py
│   │   ├── history.py
│   │   ├── manager.py
│   │   ├── preferences.py
│   │   ├── project_inference.py
│   │   └── session.py
│   ├── execution
│   │   ├── adaptive_engine.py
│   │   ├── engine.py
│   │   ├── error_recovery.py
│   │   ├── filesystem.py
│   │   └── rollback.py
│   ├── integrations.py
│   ├── intent
│   │   ├── advanced_planner.py
│   │   ├── models.py
│   │   └── planner.py
│   ├── monitoring
│   │   ├── __init__.py
│   │   ├── background.py
│   │   └── network_monitor.py
│   ├── orchestrator.py
│   ├── safety
│   │   ├── __init__.py
│   │   ├── adaptive_confirmation.py
│   │   ├── classifier.py
│   │   ├── confirmation.py
│   │   ├── preview.py
│   │   └── validator.py
│   ├── shell
│   │   ├── angela.bash
│   │   ├── angela.zsh
│   │   └── formatter.py
│   ├── utils
│   │   ├── __init__.py
│   │   └── logging.py
│   └── workflows
│       ├── __init__.py
│       ├── manager.py
│       └── sharing.py
├── pyproject.toml
├── pytest.ini
├── requirements.txt
├── scripts
│   ├── install.sh
│   └── uninstall.sh
├── setup.py
└── tests
    ├── __init__.py
    ├── conftest.py
    ├── test_ai_client.py
    ├── test_context.py
    ├── test_execution.py
    ├── test_file_detector.py
    ├── test_filesystem.py
    ├── test_integration.py
    ├── test_orchestration.py
    ├── test_prompt_building.py
    ├── test_response_parsing.py
    └── test_safety.py

15 directories, 79 files
```
