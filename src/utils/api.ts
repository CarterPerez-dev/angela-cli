// api.ts

/**
 * Represents a task item.
 */
export interface Task {
  id: string; // Unique identifier for the task (e.g., UUID or DB ID)
  title: string;
  description?: string;
  completed: boolean;
  createdAt?: string; // ISO date string, typically set by the backend
  updatedAt?: string; // ISO date string, typically set by the backend
}

/**
 * Data required to create a new task.
 * 'id', 'createdAt', and 'updatedAt' are typically generated by the backend.
 */
export type CreateTaskData = Omit<Task, 'id' | 'createdAt' | 'updatedAt'>;

/**
 * Data allowed for updating an existing task.
 * 'id', 'createdAt', and 'updatedAt' are generally not updatable directly by clients.
 */
export type UpdateTaskData = Partial<Omit<Task, 'id' | 'createdAt' | 'updatedAt'>>;

// Base URL for the API.
// In a Create React App project, you can set this via an environment variable
// (e.g., REACT_APP_API_BASE_URL in a .env file).
// Falls back to '/api' which can be useful if you're proxying API requests
// through the same server that serves your React app.
const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || '/api';

/**
 * Helper function to handle common fetch logic and error handling.
 * @param {string} url - The full URL to fetch.
 * @param {RequestInit} [options] - Optional fetch options.
 * @returns {Promise<any>} A promise that resolves to the parsed JSON response.
 * @throws {Error} If the network response is not ok or parsing fails.
 */
async function handleApiResponse(response: Response): Promise<any> {
  if (!response.ok) {
    let errorMessage = `API Error: ${response.status} ${response.statusText}`;
    try {
      const errorBody = await response.json();
      errorMessage = errorBody.message || errorBody.error || errorMessage;
    } catch (e) {
      // If response body is not JSON or empty, use the default error message
    }
    throw new Error(errorMessage);
  }

  // Handle cases where response might be empty (e.g., 204 No Content for DELETE)
  if (response.status === 204 || response.headers.get('content-length') === '0') {
    return undefined; // Or an empty object/array as appropriate for the call
  }

  return response.json();
}

/**
 * Fetches all tasks from the API.
 * @returns {Promise<Task[]>} A promise that resolves to an array of tasks.
 */
export const getTasks = async (): Promise<Task[]> => {
  const response = await fetch(`${API_BASE_URL}/tasks`);
  return handleApiResponse(response);
};

/**
 * Fetches a single task by its ID.
 * @param {string} id - The ID of the task to fetch.
 * @returns {Promise<Task>} A promise that resolves to the task.
 */
export const getTaskById = async (id: string): Promise<Task> => {
  const response = await fetch(`${API_BASE_URL}/tasks/${id}`);
  return handleApiResponse(response);
};

/**
 * Creates a new task.
 * @param {CreateTaskData} taskData - The data for the new task.
 * @returns {Promise<Task>} A promise that resolves to the newly created task.
 */
export const createTask = async (taskData: CreateTaskData): Promise<Task> => {
  const response = await fetch(`${API_BASE_URL}/tasks`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(taskData),
  });
  return handleApiResponse(response);
};

/**
 * Updates an existing task.
 * @param {string} id - The ID of the task to update.
 * @param {UpdateTaskData} taskUpdateData - The data to update the task with.
 * @returns {Promise<Task>} A promise that resolves to the updated task.
 */
export const updateTask = async (
  id: string,
  taskUpdateData: UpdateTaskData,
): Promise<Task> => {
  const response = await fetch(`${API_BASE_URL}/tasks/${id}`, {
    method: 'PUT', // Or 'PATCH' if your API supports partial updates with PATCH
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(taskUpdateData),
  });
  return handleApiResponse(response);
};

/**
 * Deletes a task by its ID.
 * @param {string} id - The ID of the task to delete.
 * @returns {Promise<void>} A promise that resolves when the task is successfully deleted.
 */
export const deleteTask = async (id: string): Promise<void> => {
  const response = await fetch(`${API_BASE_URL}/tasks/${id}`, {
    method: 'DELETE',
  });
  await handleApiResponse(response); // For DELETE, this might return undefined if 204
};

// Example of a more specific API function if needed, e.g., toggling task completion
/**
 * Toggles the completion status of a task.
 * @param {string} id - The ID of the task.
 * @param {boolean} completed - The new completion status.
 * @returns {Promise<Task>} A promise that resolves to the updated task.
 */
export const toggleTaskCompletion = async (id: string, completed: boolean): Promise<Task> => {
  // This could be a PATCH request to /tasks/{id} with { completed: ... }
  // Or a dedicated endpoint like /tasks/{id}/toggle
  // For this example, we'll use the general updateTask function.
  // If your backend has a more specific endpoint, you might implement it differently.
  return updateTask(id, { completed });
};